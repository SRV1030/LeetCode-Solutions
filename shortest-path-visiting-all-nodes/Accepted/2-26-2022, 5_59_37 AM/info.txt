{"id":648934138,"lang":"java","time":"2 weeks, 2 days","timestamp":1645834477,"status_display":"Accepted","runtime":"10 ms","url":"/submissions/detail/648934138/","is_pending":"Not Pending","title":"Shortest Path Visiting All Nodes","memory":"41.8 MB","code":"class Solution {\n    private int[][] cache;\n    private int endingMask;\n    \n    public int dp(int node, int mask, int[][] graph) {\n        if (cache[node][mask] != 0) {\n            return cache[node][mask];\n        }\n        if ((mask & (mask - 1)) == 0) {\n            // Base case - mask only has a single \"1\", which means\n            // that only one node has been visited (the current node)\n            return 0;\n        }\n        \n        cache[node][mask] = Integer.MAX_VALUE - 1; // Avoid infinite loop in recursion\n        for (int neighbor: graph[node]) {\n            if ((mask & (1 << neighbor)) != 0) {\n                int alreadyVisited = dp(neighbor, mask, graph);\n                int notVisited = dp(neighbor, mask ^ (1 << node), graph);\n                int betterOption = Math.min(alreadyVisited, notVisited);\n                cache[node][mask] = Math.min(cache[node][mask], 1 + betterOption);\n            }\n        }\n        \n        return cache[node][mask];\n    }\n    \n    public int shortestPathLength(int[][] graph) {\n        int n = graph.length;\n        endingMask = (1 << n) - 1;\n        cache = new int[n + 1][endingMask + 1];\n        \n        int best = Integer.MAX_VALUE;\n        for (int node = 0; node < n; node++) {\n            best = Math.min(best, dp(node, endingMask, graph));\n        }\n        \n        return best;\n    }\n}","compare_result":"111111111111111111111111111111111111111111111111111","title_slug":"shortest-path-visiting-all-nodes"}