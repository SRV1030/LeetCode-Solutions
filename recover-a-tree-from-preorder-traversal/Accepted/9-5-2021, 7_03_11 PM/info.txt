{"id":549862074,"lang":"cpp","time":"6 months, 1 week","timestamp":1630847891,"status_display":"Accepted","runtime":"72 ms","url":"/submissions/detail/549862074/","is_pending":"Not Pending","title":"Recover a Tree From Preorder Traversal","memory":"358.4 MB","code":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic: int n;\n    TreeNode* pre(string t,int &i,int depth){\n        if(i>=n) return NULL;\n        int pInd=i,cv=0,cd=0;\n        while(i<n && t[i]=='-'){\n            i++;cd++;\n        }\n        while(i<n && isdigit(t[i])){\n            cv=cv*10+t[i]-'0';\n            i++;\n        }\n        if(cd<depth){//Rchild\n            i=pInd;\n            return NULL;\n        }\n        TreeNode* root= new TreeNode(cv);\n        root->left= pre(t,i,depth+1);\n        root->right= pre(t,i,depth+1);\n        return root;\n        \n    }\n    TreeNode* recoverFromPreorder(string t) {\n        int i=0;\n        n=t.size();\n        return pre(t,i,0);\n    }\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"recover-a-tree-from-preorder-traversal"}