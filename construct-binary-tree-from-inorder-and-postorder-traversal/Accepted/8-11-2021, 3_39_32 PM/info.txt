{"id":536763994,"lang":"c","time":"7Â months","timestamp":1628675672,"status_display":"Accepted","runtime":"12 ms","url":"/submissions/detail/536763994/","is_pending":"Not Pending","title":"Construct Binary Tree from Inorder and Postorder Traversal","memory":"12.1 MB","code":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\n\nstruct TreeNode* buildTree(int* inorder, int inlen, int* postorder, int postlen){\n    if(inlen == 0) return NULL;\n\t\n    // Last elem of postorder must be (sub)tree's root\n    struct TreeNode* curr = malloc(sizeof(struct TreeNode));\n    curr->val = postorder[postlen-1];\n\t\n    // Find partition index\n    int mid = 0;\n    while(inorder[mid]!=curr->val) ++mid;\n\t\n    curr->left = buildTree(&inorder[0], mid, &postorder[0], mid);\n    curr->right = buildTree(&inorder[mid+1], inlen-mid-1, &postorder[mid], inlen-mid-1);\n    return curr;\n}","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"construct-binary-tree-from-inorder-and-postorder-traversal"}