{"id":508260880,"lang":"cpp","time":"9Â months","timestamp":1623759740,"status_display":"Accepted","runtime":"16 ms","url":"/submissions/detail/508260880/","is_pending":"Not Pending","title":"Subtree of Another Tree","memory":"29.3 MB","code":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:vector<TreeNode*>v;\n    void FindAll(TreeNode*root,int k){\n        if(!root)return;\n        if(root->val==k) v.push_back(root);\n        FindAll(root->left,k);\n        FindAll(root->right,k);        \n    }\n    bool Check(TreeNode* r, TreeNode* s){\n        if((r && !s)|| (!r && s)) return false;\n        if(!r && !s) return true;\n        if(r->val==s->val){\n            return Check(r->left,s->left) && Check(r->right,s->right);\n        }\n        else return false;\n    }\n    bool isSubtree(TreeNode* root, TreeNode* subRoot) {\n        v.clear();\n        TreeNode *t=root;\n        FindAll(t,subRoot->val);\n        for(auto i:v){\n            if(Check(i,subRoot)) return true;\n        }\n        return false;\n    }\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"subtree-of-another-tree"}