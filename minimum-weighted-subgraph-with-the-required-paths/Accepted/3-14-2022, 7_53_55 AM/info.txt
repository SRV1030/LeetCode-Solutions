{"id":659526076,"lang":"cpp","time":"34Â minutes","timestamp":1647223735,"status_display":"Accepted","runtime":"680 ms","url":"/submissions/detail/659526076/","is_pending":"Not Pending","title":"Minimum Weighted Subgraph With the Required Paths","memory":"193 MB","code":"#define pp pair<long long,long long>\nclass Solution {\npublic:\n    void shortestPath(vector<vector<pp>>g,vector<long long>&dist,int start){\n        priority_queue<pp,vector<pp>,greater<pp>>pq;\n        pq.push({0,start});\n        while(!pq.empty()){\n            auto [wt,u]=pq.top();\n            pq.pop();\n            if(dist[u]!=wt)continue;\n            for(auto [uu,wt2]:g[u]){\n                // cout<<u<<\" \"<<uu<<\" \";\n                if(dist[uu]>dist[u]+wt2){\n                    dist[uu]=dist[u]+wt2;\n                    pq.push({dist[uu],uu});\n                }\n            }\n        }\n    }\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\n         vector<vector<pp>>g(n),g1(n);\n        //let n1 be the point where src1 and src2 meets\n        for(auto edge:edges){\n            g[edge[0]].push_back({edge[1],edge[2]});\n            //g1 an opposite graph to get the dest to n1(where src1 and src2 meets)\n            g1[edge[1]].push_back({edge[0],edge[2]});\n        }\n        \n        vector<long long>dista(n,LONG_MAX),distb(n,LONG_MAX),distn(n,LONG_MAX);\n        dista[src1]=distb[src2]=distn[dest]=0;\n        shortestPath(g,dista,src1);\n        shortestPath(g,distb,src2);\n        shortestPath(g1,distn,dest);\n        long long ans=LONG_MAX;\n        for(int i=0;i<n;i++){\n            if(dista[i]==LONG_MAX||distb[i]==LONG_MAX||distn[i]==LONG_MAX)continue;\n            ans=min(ans,dista[i]+distb[i]+distn[i]);\n        }\n        return ans==LONG_MAX?-1:ans;\n    }\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"minimum-weighted-subgraph-with-the-required-paths"}